package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/signal"
	"path"
	"strconv"
	"strings"
	"text/template"
	"time"

	"codes/gogin/protos"

	"github.com/gin-gonic/gin"
)

func formatAsDate(t time.Time) string {
	y, m, d := t.Date()
	return fmt.Sprintf("%d/%02d/%02d", y, m, d)
}

func SetupRouter() *gin.Engine {
	gin.DisableConsoleColor()
	// gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) {
	// 	log.Printf("endpoint %v %v %v %v\n", httpMethod, absolutePath, handlerName, nuHandlers)
	// }
	f, _ := os.Create("gin.log")
	gin.DefaultWriter = io.MultiWriter(f, os.Stdout)

	r := gin.Default()
	r.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
		// 你的自定义格式
		return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
			param.ClientIP,
			param.TimeStamp.Format(time.RFC1123),
			param.Method,
			param.Path,
			param.Request.Proto,
			param.StatusCode,
			param.Latency,
			param.Request.UserAgent(),
			param.ErrorMessage,
		)
	}))

	r.Use(UselessMiddleware())

	r.Static("/static", "./static")
	r.SetFuncMap(template.FuncMap{
		"formatAsDate": formatAsDate,
	}) // 必须在下面那行(或类似模板解析函数)之前
	r.LoadHTMLGlob("templates/**/*")

	AsciiJson(r)
	HtmlRender(r)
	Http2Push(r)
	JsonP(r)

	MultipartBinding(r)
	MultipartForm(r)

	PureJson(r)
	Json(r)
	ProtobufData(r)

	r.MaxMultipartMemory = 8 << 20 // 8 MiB
	UploadSingleFile(r)
	UploadMultipleFiles(r)

	SendFromReader(r)

	WithBasicAuth(r)

	QueryFormMap(r)

	CheckboxBinding(r)

	UriBinding(r)

	CookieDemo(r)

	v2 := r.Group("/v2")
	{
		v2.GET("/*p", func(ctx *gin.Context) {
			ctx.Request.URL.Path = ctx.Param("p")
			r.HandleContext(ctx)
		})
	}

	return r
}

func CookieDemo(r *gin.Engine) {
	r.GET("/cookie", func(ctx *gin.Context) {
		cookie, err := ctx.Cookie("gin_cookie")
		if err != nil {
			ctx.SetCookie("gin_cookie", "一些存储在cookie的数据", 3600, "/", "localhost", false, false)
			ctx.String(http.StatusOK, "请刷新页面")
			return
		}
		ctx.String(http.StatusOK, cookie)
	})
}

type UriBindingS struct {
	Kind string `uri:"kind" binding:"required"`
	Name string `uri:"name" binding:"required"`
}

// xh GET "https://localhost:9999/uribinding/fruit/apple" --verify false
func UriBinding(r *gin.Engine) {
	r.GET("/uribinding/:kind/:name", func(ctx *gin.Context) {
		var s UriBindingS
		if err := ctx.ShouldBindUri(&s); err != nil {
			ctx.JSON(400, gin.H{
				"message": err.Error(),
			})
			return
		}
		ctx.JSON(http.StatusOK, gin.H{
			"kind": s.Kind,
			"id":   s.Name,
		})
	})
}

type CheckboxForm struct {
	Colors []string `form:"colors"`
}

func CheckboxBinding(r *gin.Engine) {
	r.GET("/checkbox", func(ctx *gin.Context) {
		ctx.HTML(http.StatusOK, "misc/checkbox.html", nil)
	})
	r.POST("/checkbox", func(ctx *gin.Context) {
		var form CheckboxForm
		if err := ctx.Bind(&form); err != nil {
			//
		} else {
			log.Println(form)
		}
	})
}

// xh POST "https://localhost:9999/qfmap?ids[a]=1234&ids[b]=abcd" -f names[a]=aaaa names[b]=bbbb --verify false
func QueryFormMap(r *gin.Engine) {
	r.POST("/qfmap", func(ctx *gin.Context) {
		ids := ctx.QueryMap("ids")
		names := ctx.PostFormMap("names")

		fmt.Printf("ids: %v, names: %v\n", ids, names)
	})
}

func UselessMiddleware() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		if ctx.Request.RequestURI == "/useless" {
			ctx.JSON(http.StatusOK, gin.H{
				"message": "generated by UselessMiddleware",
			})
		} else {
			ctx.Next()
		}
	}
}

var authinfo = gin.H{
	"foo": gin.H{"name": "Foo", "age": 18, "sex": "male"},
	"bar": gin.H{"name": "Bar", "age": 22, "sex": "female"},
}

// xh GET https://localhost:9999/auth/someinfo --verify false -A basic --auth shenmiren:999
func WithBasicAuth(r *gin.Engine) {
	authorized := r.Group("/auth", gin.BasicAuth(gin.Accounts{
		"foo":       "bar",
		"admin":     "123",
		"shenmiren": "999",
	}))

	authorized.GET("/someinfo", func(ctx *gin.Context) {
		user := ctx.MustGet(gin.AuthUserKey).(string)
		if info, ok := authinfo[user]; ok {
			ctx.JSON(http.StatusOK, info)
		} else {
			ctx.JSON(http.StatusOK, gin.H{
				"message": "who are you?",
			})
		}
	})
}

func SendFromReader(r *gin.Engine) {
	r.GET("/somedata", func(ctx *gin.Context) {
		s := "<p>data from a reader</p>"
		rdr := strings.NewReader(s)
		contentLength := len(s)
		contentType := "text/html; charset=utf-8"
		ctx.DataFromReader(http.StatusOK, int64(contentLength), contentType, rdr, nil)
	})

}

func UploadLargeFile(r *gin.Engine) {
	// TODO
}

func UploadMultipleFiles(r *gin.Engine) {
	r.POST("/upload-multiple", func(ctx *gin.Context) {
		form, _ := ctx.MultipartForm()
		files := form.File["files"]

		for _, file := range files {
			log.Println(file.Filename)
			dst := path.Join(".", "uploaded", file.Filename)
			ctx.SaveUploadedFile(file, dst)
		}
	})
}

func UploadSingleFile(r *gin.Engine) {
	r.GET("/upload", func(ctx *gin.Context) {
		ctx.HTML(http.StatusOK, "misc/upload.html", nil)
	})

	r.POST("/upload", func(ctx *gin.Context) {
		file, err := ctx.FormFile("file")
		if err != nil {
			log.Println(err)
			return
		}
		log.Printf("upload file: %s\n", file.Filename)

		dst := path.Join(".", "uploaded", file.Filename)
		ctx.SaveUploadedFile(file, dst)
		ctx.String(http.StatusOK, fmt.Sprintf("'%s' uploaded!", file.Filename))
	})
}

func ProtobufData(r *gin.Engine) {
	r.GET("/someproto", func(ctx *gin.Context) {
		data := &protos.Greeting{
			Message: "hello",
			Label:   []int64{1, 2, 3},
		}
		ctx.ProtoBuf(http.StatusOK, data)
	})
}

// xh GET https://localhost:9999/json --verify false
// Content-Length: 47
func Json(r *gin.Engine) {
	r.GET("/json", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{
			"html": "<p>pure json</p>",
		})
	})
}

// xh GET https://localhost:9999/purejson --verify false
// Content-Length: 28
func PureJson(r *gin.Engine) {
	r.GET("/purejson", func(ctx *gin.Context) {
		ctx.PureJSON(http.StatusOK, gin.H{
			"html": "<p>pure json</p>",
		})
	})
}

// xh POST https://localhost:9999/form_post -f message=hello --verify false
func MultipartForm(r *gin.Engine) {
	r.POST("/form_post", func(ctx *gin.Context) {
		message := ctx.DefaultPostForm("message", "nothing")
		ctx.JSON(http.StatusOK, gin.H{
			"status":  "posted",
			"message": message,
		})
	})
}

type LoginForm struct {
	UserName string `form:"user" json:"user" binding:"required"`
	Password string `form:"password" json:"password" binding:"required"`
}

// xh POST https://localhost:9999/login -j user=admin password=12345 --verify false
// xh POST https://localhost:9999/login -f user=admin password=12345 --verify false
func MultipartBinding(r *gin.Engine) {
	r.POST("login", func(ctx *gin.Context) {
		var login LoginForm
		if err := ctx.ShouldBind(&login); err == nil {
			if login.UserName == "admin" && login.Password == "12345" {
				ctx.JSON(http.StatusOK, gin.H{"message": "ok"})
				return
			}
		}
		ctx.JSON(http.StatusOK, gin.H{"message": "failed to login"})
	})
}

var jsonpUsers = map[int]string{
	1: "jim",
	2: "jack",
	3: "mary",
}

func JsonP(r *gin.Engine) {
	r.GET("/JSONP", func(ctx *gin.Context) {
		uid := ctx.DefaultQuery("uid", "-1")
		id, err := strconv.Atoi(uid)
		if err == nil {
			nickname, exist := jsonpUsers[id]
			if exist {
				ctx.JSONP(http.StatusOK, nickname)
				return
			}
		}
		ctx.JSONP(http.StatusOK, "anonymous")
	})
}

func Http2Push(r *gin.Engine) {
	r.GET("/push", func(ctx *gin.Context) {
		if pusher := ctx.Writer.Pusher(); pusher != nil {
			if err := pusher.Push("/static/ye.jpg", nil); err != nil {
				log.Printf("failed to push file: %v", err)
			}
		}
		ctx.HTML(http.StatusOK, "miscs/push.html", nil)
	})
}

func HtmlRender(r *gin.Engine) {
	r.GET("/posts/index", func(ctx *gin.Context) {
		ctx.HTML(http.StatusOK, "posts/index.html", gin.H{
			"title": "Post",
			"now":   time.Now(),
		})
	})
	r.GET("/users/index", func(ctx *gin.Context) {
		ctx.HTML(http.StatusOK, "users/index.html", gin.H{
			"title": "User",
		})
	})
}

func AsciiJson(r *gin.Engine) {
	r.GET("/asciijson", func(ctx *gin.Context) {
		data := gin.H{
			"lang": "Go语言",
			"features": []string{
				"simple",
				"concurrent",
			},
		}
		ctx.AsciiJSON(http.StatusOK, data)
	})
}

func main() {
	r := SetupRouter()

	srv := &http.Server{
		Addr:    ":9999",
		Handler: r,
	}

	go func() {
		if err := srv.ListenAndServeTLS("cert.pem", "key.pem"); err != nil && err != http.ErrServerClosed {
			log.Fatalf("listen: %v\n", err)
		}
	}()

	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt)
	<-quit
	log.Println("Shutdown...")

	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		log.Fatal("Server Shutdown:", err)
	}
	log.Println("Server exiting")
}
